#summary Using Crystal's dataflow analysis
#labels Phase-Support

= Introduction =

Crystal comes with a [http://en.wikipedia.org/wiki/Dataflow_analysis dataflow analysis] implementation based on an efficient "worklist" algorithm.  It requires customization with analysis-specific lattice values and transfer functions.  This page explains how to customize and use the dataflow analysis implementation.  We talk about intra-procedural analyses here; however, people have successfully implemented inter-procedural analyses with Crystal as well.  This page will usually use the shorter term "flow analysis" instead of "dataflow analysis".  This page also assumes familiarity with flow analysis concepts, including forward vs. backwards analyses, lattices, and transfer functions.

Using Crystal's dataflow analysis involves the following steps:

  * Create lattice value class
  * Create a lattice operations class which implements ILatticeOperations
  * Create transfer function implementation class (multiple options; all extending `IFlowAnalysisDefinition`)
  * Instantiate and query flow analysis in your Crystal Analysis (see GettingStarted).

An important thing to realize when writing a flow analysis is that the flow analysis is just a means to an end: a flow analysis *computes* some information about *every node* in a control flow graph.  We typically query this information _subsequently_ to find error conditions.

The package `edu.cmu.cs.crystal.simple` contains a facade over more complex interfaces; we will assume you are the simple interfaces for now. The complex interfaces are in `edu.cmu.cs.crystal.flow`.

= Lattice Value Implementation =

Lattice values represent the information tracked by your flow analysis.  For instance, in a divide-by-zero analysis, a lattice _value_ would be a particular mapping from local variables to one of "zero", "non-zero" or "maybe-zero".  

For your analysis, you create a class, say, `MyLE`. You can use an *enum* class if your lattice has a fixed number of constant elements. Instances of this class will represent individual lattice values, which your transfer function will typically instantiate.

If you will eventually use this lattice value in a tuple lattice, the lattice element must implement `edu.cmu.cs.crystal.util.Copyable`.

Done. That was easy, wasn't it?

= Lattice Operations =

A lattice isn't very useful unless you can do some operations on it. You'll need to create a class which implements `ILatticeOperations`. We suggest extending off of `edu.cmu.cs.crystal.simple.SimpleLatticeOperations`. You must parameterize your operations with the lattice element type you created earlier. In our example, your new class might start like this:

{{{
public class MyLatticeOps extends SimpleLatticeOperations<MyLE> {
   ...
}

}}}

Implementing `SimpleLatticeOperations` will require implementing a number of methods, most of which correspond directly to lattice theory:

  * `atLeastAsPrecise` compares two of your lattice values and determines if the information in the receiver implies the information in the argument (i.e., if the receiver is at least as precise as the argument). This is the comparison operator in lattice theory.

  * `join` returns a new value that approximates the receiver and argument values. This is the join operator in lattice theory.

  * `bottom` returns a new value that is the bottommost element in the lattice.

  * `copy` performs a "deep copy" of the receiver. *copy and original referencing the same mutable state will lead to subtle bugs* when running the flow analysis.

While the first three methods are from lattice theory, `copy` is purely an implementation device.  Since Crystal needs to keep analysis information separately for every program point it will call `copy` to give you a separate copy of the analysis information to work with in transfer functions (see below).  Notice that Crystal will `copy` all the time, so if your lattice values are really big, you may want to think about some [optimizations LatticeOptimizations] here.

= Transfer Function Implementation =

A transfer function "transfers" your analysis information over a given program instruction.  In other words, if N is an instruction and I is a given lattice value (called the "incoming" value) then a transfer function is a function f that computes new analysis information O = f(N, I) from the incoming information and what is going on in the instruction.  For instance, if you're tracking whether variables are zero, and N is `x = 0`, then you want O to be like I, except with whatever I says about x changed to x being definitely zero.

Now there are a ton of different kinds of instructions (method calls, assignments, arithmetic, etc.), and the behavior of a transfer function tends to depend greatly on the *kind of instruction* it transfers over.  So transfer functions are typically implemented with separate methods for each kind of instruction, and Crystal in fact defines interfaces for that.  But that is in a sense optional.

All transfer functions in Crystal implement `IFlowAnalysisDefinition`.  This interface defines two methods, for determining the analysis direction and the lattice to be used for analyzing a given method, that are needed for running any flow analysis.  While these do not do any transferring, they are tightly related to the actual transfer function.

== Analysis Direction ==

A flow analysis works either _forward_ or _backwards_.  The `getAnalysisDirection` method of a transfer function implementation class defines which one it is.  Depending on what is chosen here, the lattice information passed into a transfer function call by Crystal is either the currently known information before (for forward analyses) or after (for backwards analyses) the instruction to be processed.  It is useful to keep this in mind.

== Lattice Operations ==

== Starting Lattice ==

The `getLattice` method must return a `Lattice` instance, which gives Crystal the initial lattice value to be used for analyzing a given method.  This gives you the opportunity to pre-populate the lattice with information known at the beginning of a method, such as assumptions about the method receiver and parameters.

== Transfer functions ==

Transfer functions conventionally compute outgoing analysis information O based on incoming information I, where both O and I are lattice values.  If this is what you want then 

= Getting the flow results from the visitor = 