#summary Using Crystal's dataflow analysis

= Introduction =

Crystal comes with a [http://en.wikipedia.org/wiki/Dataflow_analysis dataflow analysis] implementation based on an efficient "worklist" algorithm.  It requires customization with analysis-specific lattice values and transfer functions.  This page explains how to customize and use the dataflow analysis implementation.  We talk about intra-procedural analyses here; however, people have successfully implemented inter-procedural analyses with Crystal as well.  This page will usually use the shorter term "flow analysis" instead of "dataflow analysis".  This page also assumes familiarity with flow analysis concepts such as forward vs. backwards analysis.

Using Crystal's dataflow analysis involves the following steps:

  * Create lattice value implementation class that implements `LatticeElement`.
  * Create transfer function implementation class (multiple options)
  * Instantiate and query flow analysis in your Crystal Analysis (see GettingStarted).

An important thing to realize when writing a flow analysis is that the flow analysis is just a means to an end: a flow analysis *computes* some information about *every node* in a control flow graph.  We typically query this information _subsequently_ to find error conditions.

= Lattice Value Implementation =

Lattice values represent the information tracked by your flow analysis.  For instance, in a divide-by-zero analysis, a lattice _value_ would be a particular mapping from local variables to one of "zero", "non-zero" or "maybe-zero".  

For your analysis, you create a class, say, `MyLE`, that *must* implement Crystal's `LatticeElement` interface.  (You can use an *enum* class that implements this interface if your lattice has a fixed number of constant elements.)  Instances of this class will represent individual lattice values, which your transfer function will typically instantiate.  

Implementing `LatticeElement` will require implementing a number of methods, some of which correspond directly to lattice theory, and others are defined for implementation reasons:

  * `atLeastAsPrecise` compares two of your lattice values and determines if the information in the receiver implies the information in the argument (i.e., if the receiver is at least as precise as the argument).

  * `join` returns a new value (we recommend you instantiate a new instance of `MyLE`) that approximates the receiver and argument values.

  * `copy` *must* perform a "deep copy" of the receiver: *copy and original referencing the same mutable state will lead to subtle bugs* when running the flow analysis.

While the first two methods correspond to the comparison and join operators from lattice theory, `copy` is purely an implementation device.  Since Crystal needs to keep analysis information separately for every program point it will call `copy` to give you a separate copy of the analysis information to work with in transfer functions (see below).  Notice that Crystal will `copy` all the time, so if your lattice values are really big, you may want to think about some optimizations here.  We will revisit this issue later.

= Transfer Function Implementation =

A transfer function "transfers" your analysis information over a given program instruction.  In other words, if N is an instruction and I is a given lattice value (called the "incoming" value) then a transfer function is a function f that computes new analysis information O = f(N, I) from the incoming information and what is going on in the instruction.  For instance, if you're tracking whether variables are zero, and N is `x = 0`, then you want O to be like I, except with whatever I says about x changed to x being definitely zero.

Now there are a ton of different kinds of instructions (method calls, assignments, arithmetic, etc.), and the behavior of a transfer function tends to depend greatly on the *kind of instruction* it transfers over.  So transfer functions are typically implemented with separate methods for each kind of instruction, and Crystal in fact defines interfaces for that.  But that is in a sense optional.

== Analysis Direction ==

A flow analysis works either _forward_ or _backwards_.  

== Conventional Branch-insensitive Flow Analyses ==

== Branch-sensitive Flow Analyses ==

== Three-Address Code ==

= Using Flow Analysis Driver =